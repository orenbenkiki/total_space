Total Space
===========

Investigate the total state space of communicating finite state machines. Specifically,
given a model of a system comprising of
multiple agents,
where each agent is a non-deterministic state machine,
which responds to either time or receiving a message with one of some possible actions,
where each such action can change the agent state and/or send messages to other agents;
Then this package will generate the total possible state space of the overall system,
validate the model for completeness,
validate each system state for additional arbitrary correctness criteria,
and visualize the states and transitions in various ways.

Requirements
------------

Python 3.5 or above.

Installation
------------

Run ``pip3 --install total_space``.

Usage
-----

Create a ``model.py`` file that:

* Imports the ``total_space`` module.

* Declares state and agent classes for modeling some system.

* Provides functions for:

  * (Optionally) add command line flags to control the model creation.

  * Create a function that creates the model given the parsed command line flags.

  * (Optionally) report invalid conditions in a global system configuration.

* Invokes the ``total_space.main`` function, passing it the above.

You can now run ``python3 model.py`` to do the following:

* Generate a list of all the possible system configuration states.
  Each system configuration state contains the state of all the agents,
  the messages that are in flight, and invalid conditions (if any).
  A complete and correct model would contain no invalid conditions.

* Generates a tab-separated file of all the transitions between the possible system configuration states.
  The code doesn't generate any transitions from an invalid system configuration state.

* Generate a ``dot`` file visualizing the transitions between the system configuration states.
  Invalid system configuration states are highlighted.

* Focus only on the states of specific agent(s).

Run ``python3 model.py -h`` for details.

Example
-------

A very simple model of a client serving any number of clients (one request at a time) is available
in the tests directory. It demonstrates the basic usage of this package.

Just looking at all the possible states, generated by ``python3 -m total_space.simple_model --names
states`` can also be useful to get a feel for the model. One can also generate all the transitions
as a tab-separated file using ``--names transitions`` instead. These are also
useful for further automated processing. However these aren't very useful in communicating the model's
logic to humans.

To generate diagrams for visualizing the state machine, you can run ``python3 -m
total_space.simple_model.py dot | dot -Tpng > complete.png``. This will generate a large, detailed,
and hard to understand diagram, which might still be useful when debugging invalid and/or partial
models; see the results of ``--partial dot`` and/or ``--invalid dot``.

To generate more legible diagrams, it is possible to merge total system configuration states
in three ways:

* Using ``--names`` to ignore the internal state data.

* Using ``--agents`` to ignore the messages-in-flight.

* Using ``--focus AGENT`` (possibly several times) to ignore agents which are not in the focus.

These options will merge otherwise-different system configuration states. Note this is done as a
post-processing on the computed total states space.

In addition, it is possible to control the generated ``dot`` graph:

* Using ``--messages`` will create a separate node for each in-flight message.

* Using ``--merge`` will merge nodes that only differ by the list of in-flight messages.
  This is different from ``--agents`` above since here we keep the transitions between
  the states, and only merge them to a single node at the last moment.

Choosing the right combination of restrictions to highlight specific parts of the logic
is a matter of taste and depends very much on the model and what you are trying to achieve.
In this specific case, the following work well:

* Very simplified but complete state machine: ``--names dot --messages --merge``.

* Focusing only on the server: ``--names --focus server dot --messages --merge``.

* Focusing only on the client: ``--names --focus client-1 dot --messages --merge``.
